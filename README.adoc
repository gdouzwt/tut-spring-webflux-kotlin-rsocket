:toc:
:icons: font
:source-highlighter: prettify
:project_id: tut-spring-webflux-kotlin-rsocket
:tabsize: 2
:image-width: 500
:images: https://raw.githubusercontent.com/spring-guides/tut-spring-webflux-kotlin-rsocket/master/static
:book-root: .

本教程给你演示如何使用Spring Boot和Kotlin写一个简单的聊天应用。你会学习到从语法层面看使用做服务端开发的语法的好处。

我们将会从一个实现了最小功能的应用开始，然后逐步完善。刚开始，应用会生成和显示假消息，并使用经典的阻塞请求-响应模型去获取数据到UI上。
通过本教程，我们通过添加持久化层和一些扩展去完善应用，并迁移到一个非阻塞的面向流的风格来去将数据从后端服务到UI。

本教程由5部分组成：

* 第1部分 初始化设置以及工程简介
* 第2部分 添加持久化层并集成测试
* 第3部分 实现扩展
* 第4部分 重构为使用Spring WebFlux和Kotlin Coroutines
* 第5部分 使用RSocket进行流式传输

这个教程面向已经熟悉 Spring MVC/ WebFlux 并想了解在 Spring 使用 Kotlin 的Java开发者。


== 第1部分：初始化设置及工程简介

要开始本教程，我们需要其中一个版本的 IntelliJ IDEA - 任何 2018.1 以上的版本都可以。 你可以下载最新的免费社区版。

这个工程是基于 Spring Boot 2.4.0的，这个版本需要 Kotlin 1.4.10。 请确保 1.4+ 版本的 Kotlin 插件以安装。要升级 Kotlin 插件，可以去菜单 `Tools | Kotlin | Configure Kotlin Plugin Updates`

=== 下载工程

在 IntelliJ IDEA 通过选择 `File | New | Project from Version Control`去克隆代码仓库。

image::{images}/download-from-vcs.png[]

指定工程的路径：http://github.com/kotlin-hands-on/kotlin-spring-chat.

image::{images}/download-from-vcs-github.png[]

当你克隆了工程，IntelliJ IDEA会自动地导入并打开它。另外，你也可以使用以下命令克隆工程。

[source,bash]
$ git clone https://github.com/kotlin-hands-on/kotlin-spring-chat.

=== 解决方案分支

注意到工程包含教程的每一部分的解决方案分支。你可以通过在IDE中调用Branches的动作去浏览所有的分支:

image::{images}/intellij-git-branches.png[]

或者你可以使用命令行:

[source,bash]
git branch -a

可以使用IntelliJ IDEA `Compare with branch` 命令去比较你的解决方案与给出的版本。

image::{images}/intellij-git-compare-with-branch.png[]

例如，这里列出`initial`分支和`part-2`分支之间的差异:

image::{images}/intellij-git-compare-with-branch-diff.png[]

通过点击单独的文件，你可以看到行级别的更改。

image::{images}/intellij-git-compare-with-branch-file-diff.png[]

当你在此教程的任何阶段遇到教程步骤相关的问题时这应该会有帮助

=== 启动应用

那个应用的`main`方法是位于 `ChatKotlinApplication.kt`文件。直接点击 main 方法旁边的 gutter 图标，或者按下 `Alt+Enter`快捷键调用IntelliJ IDEA 的启动菜单。

image::{images}/intellij-run-app-from-main.png[]

另外，你也可以在终端命令行运行 `./gradlew bootRun`。

一旦程序启动了，打开以下 URL: http://localhost:8080 你会看到一个聊天页面有很多消息

image::{images}/chat.gif[]

在以下步骤，我会演示如何整合数据库到我们的应用去存储消息。

=== 工程概览

让我们看一下整个应用的概览。在这个教程，我们要构建一个简单的聊天应用，具有以下架构：

image::{images}/application-architecture.png[]

我们的应用是一个普通的3层web应用。面向客户端的那层是由 `HtmlController` 和 `MessageResource`类实现的。这个应用利用了服务端渲染，使用 _Thymeleaf_ 模板引擎，并且服务为 `HtmlController`。 消息数据的API是由`MessageResource`提供，

服务层是由`MessageService`表现,这个有两个不同的实现：

*   `FakeMessageService` - 起初的实现，这会产生随机消息。
*   `PersistentMessageService` - 第2个实现，使用的是真实数据存储。我们会在本教程的第2部分添加这部分实现

这个 `PersistentMessageService` 连接到数据库存储消息。我会使用 H2 数据库并通过 Spring Data Repository API 去访问它。

在你下载了工程的源码并在IDE打开后，你会看到以下目录结构，包括了前面提到的类。
image::{images}/project-tree.png[]


在 `main/kotlin` 文件夹之下有属于应用程序的包和类。在那个文件夹里，我们将会添加更多的类和让现存的代码演进成一个应用。

在那个 `main/resources` 文件夹你会发现各种静态资源和配置文件。

那个 `test/kotlin` 文件夹包含了测试用例。我们将对测试用例的源码根据应用程序的主要代码做相应的修改。

程序的入口点是 `ChatKotlinApplication.kt`文件。这里是`main`方法所在的地方。

==== HtmlController

`HtmlController`是一个被`@Controller`注解的端点，它会暴露一个通过 thymeleaf 生成的 HTML 页面。

[source,kotlin]
-----
import com.example.kotlin.chat.service.MessageService
import com.example.kotlin.chat.service.MessageVM
import org.springframework.stereotype.Controller
import org.springframework.ui.Model
import org.springframework.ui.set
import org.springframework.web.bind.annotation.GetMapping

@Controller
class HtmlController(val messageService: MessageService) {
   @GetMapping("/")
   fun index(model: Model): String {
       val messages = messageService.latest()

       model["messages"] = messages
       model["lastMessageId"] = messages.lastOrNull()?.id ?: ""
       return "chat"
   }
}
-----

💡 你可以直观地看到Kotlin的其中一个特性就是类型推导。这意味着你的代码中的一些类型信息被省略了，由编译器推导。

在我们上边的例子中，编译器通过观察`messageService.latest()`函数的返回值知道`messages`变量的类型是`List&lt;MessageVM&gt;`。

💡 Spring Web用户可能注意到在本例中那个 `Model` 用作一个 `Map` 尽管它没有扩展这个 API。
这个因为https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/kdoc-api/spring-framework/org.springframework.ui/index.html [另一个Kotlin扩展] 而成为可能，它提供了对 `set` 操作符的重载。更详细的信息，请查看https://kotlinlang.org/docs/reference/operator-overloading.html[operator overloading] 文档.

💡 Null safety 是这语言的最重要特性之一。在上边的例子中，你可以看到一个应用具有这样的特性：`messages.lastOrNull()?.id ?:""."` 首先，`?`是 safe call 操作符，这会检查 `lastOrNull()` 的结构是否为 `null`，然后得到一个 `id`。 如果表达式的结果是 `null`，那么我们可以使用一个 Elvis 操作符去提供一个默认值，这在我们的例子中是空字符串(`""`)


==== MessageResource

我们需要一个API端点服务于查询请求。这个功能点是由 `MessageResource`类实现的，它将最新的消息以 JSON 格式暴露。

如果指定 `lastMessageId` 查询参数，这个端点将从指定的消息id往后提供最新消息，否则它会提供所有可用的消息。

[source,kotlin]
-----
@RestController
@RequestMapping("/api/v1/messages")
class MessageResource(val messageService: MessageService) {

   @GetMapping
   fun latest(@RequestParam(value = "lastMessageId", defaultValue = "") lastMessageId: String): ResponseEntity<List<MessageVM>> {
       val messages = if (lastMessageId.isNotEmpty()) {
           messageService.after(lastMessageId)
       } else {
           messageService.latest()
       }

       return if (messages.isEmpty()) {
           with(ResponseEntity.noContent()) {
               header("lastMessageId", lastMessageId)
               build<List<MessageVM>>()
           }
       } else {
           with(ResponseEntity.ok()) {
               header("lastMessageId", messages.last().id)
               body(messages)
           }
       }
   }

   @PostMapping
   fun post(@RequestBody message: MessageVM) {
       messageService.post(message)
   }
}
-----

💡 在Kotlin当中， `if` 是一个表达式， 并且它会返回一个值。 这就是为什么我们可以将一个 `if` 表达式赋值给一个变量：
`val messages = if (lastMessageId.isNotEmpty()) {...}`

💡 Kotlin的标准库包含了 scope 函数，它的唯一目的就是可以去执行一个对象上下文中的一个代码块。在上边的例子中，我们使用 `with()` 函数构建了一个响应对象。


==== FakeMessageService

`FakeMessageService` 是 `MessageService` 接口最初的实现。 它为我们的聊天提供了假数据。 我们使用 Java Faker 库去生成这些假数据。 这个服务使用莎士比亚,尤达，Rick和 Morty的名言随机地生成消息。


[source,kotlin]
-----
@Service
class FakeMessageService : MessageService {

    val users: Map<String, UserVM> = mapOf(
        "Shakespeare" to UserVM("Shakespeare", URL("https://blog.12min.com/wp-content/uploads/2018/05/27d-William-Shakespeare.jpg")),
        "RickAndMorty" to UserVM("RickAndMorty", URL("http://thecircular.org/wp-content/uploads/2015/04/rick-and-morty-fb-pic1.jpg")),
        "Yoda" to UserVM("Yoda", URL("https://news.toyark.com/wp-content/uploads/sites/4/2019/03/SH-Figuarts-Yoda-001.jpg"))
    )

    val usersQuotes: Map<String, () -> String> = mapOf(
       "Shakespeare" to { Faker.instance().shakespeare().asYouLikeItQuote() },
       "RickAndMorty" to { Faker.instance().rickAndMorty().quote() },
       "Yoda" to { Faker.instance().yoda().quote() }
    )

    override fun latest(): List<MessageVM> {
        val count = Random.nextInt(1, 15)
        return (0..count).map {
            val user = users.values.random()
            val userQuote = usersQuotes.getValue(user.name).invoke()

            MessageVM(userQuote, user, Instant.now(),
                      Random.nextBytes(10).toString())
        }.toList()
    }

    override fun after(lastMessageId: String): List<MessageVM> {
        return latest()
    }

    override fun post(message: MessageVM) {
        TODO("Not yet implemented")
    }
}
-----


Kotlin的函数式类型，我们经常当作一种 lambda表达式使用。 在上面的例子中，`userQuotes` 是一个 map 对象，它的key是字符串string 然后值是 lambda expressions。 一个类型签名 `() -> String` 表示那个 lambda 表达式不接受参数，并产出 `String` 作为结果。 因此， `userQuotes` 的类型是由 `Map&lt;String, () -> String&gt;` 所指定。


💡 那个 `mapOf` 函数可让你创建一个“对”的map，这里的 pair's 定义是由 extension 方法提供的：
`&lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt;`.

💡 那个 `TODO()` 函数有两个作用:提示作用和源码调试作用，因为它总是抛出 `NotImplementedError` 异常。

`FakeMessageService` 类的主要任务是生成随机数量的假数据发送到聊天的UI。 那个 `latest()` 方法是放在这个逻辑实现的地方。




[source,kotlin]
-----
val count = Random.nextInt(1, 15)
return (0..count).map {
    val user = users.values.random()
    val userQuote = usersQuotes.getValue(user.name).invoke()

    MessageVM(userQuote, user, Instant.now(), Random.nextBytes(10).toString())
  }.toList()
-----

在 Kotlin，想要生成一个范围的整数，我们只需要写 `(0..count)`。 然后我们应用 `map()` 函数去转换每个数字成为消息。

很大程度上，从任意集合中随机选择一个元素的操作也很简单。 Kotlin 为集合框架提供了一个扩展方法，名为 `random()`
我们使用这个扩展方法去从集合中选择并返回一个用户： `users.values.random()`

一旦用户已选定，我们需要从 `userQuotes` map 里面去获取用户的引语。 从 `userQuotes` 所选中的值它实际上是一个我们获取真实引语需要调用的lambda表达式： `usersQuotes.getValue(user.name).invoke()`

下一步，我们创建一个 `MessageVM` 类的实例。 这是一个用来传送数据到客户端的视图模型。

[source,kotlin]
-----
data class MessageVM(val content: String, val user: UserVM, val sent: Instant, val id: String? = null)
-----

💡 对于 data class，编译器会自动生成 `toString`,  `equals` 和 `hashCode` 函数，最少化你所需要写的实用代码。

== 第 2 部分 添加持久化和集成测试

在这部分，我们会实现一个持久化版本的 `MessageService` 接口， 使用 Spring Data JDBC 和 H2 作为数据库。我们会引入以下类：

*   `PersistentMessageService` - `MessageService` 接口的一个实现，这会通过 Spring Data Repository API 与真实的数据存储交互。
*   `MessageRepository` – 一个 `MessageService` 使用的 repository 实现。 

=== 添加新的依赖

首先，我们需要添加必要的依赖到工程。 为此，我们需要添加下面几行到 build.gradle.kts 文件的 `dependencies` 块语句中。


[source,kotlin]
-----
implementation("org.springframework.boot:spring-boot-starter-data-jdbc")
runtimeOnly("com.h2database:h2")
-----

⚠️ 注意，在本例中， 我们使用 `spring-data-jdbc` 作为一种轻量且直接的方式去在 Spring 框架中使用 JDBC。 如果你想看到使用 JPA 的例子，请看以下博文 https://spring.io/guides/tutorials/spring-boot-kotlin/?#_persistence_with_jpa[blog post].

⚠️ 要刷新工程的依赖列表， 点击编辑器右上角的小大象图标

image::{images}/intellij-gradle-reload.png[]

=== 创建数据库模式和配置

当依赖被添加并解决了，我们可以开始对数据库模式进行建模。

[source,sql]
-----
CREATE TABLE IF NOT EXISTS messages (
  id                     VARCHAR(60)  DEFAULT RANDOM_UUID() PRIMARY KEY,
  content                VARCHAR      NOT NULL,
  content_type           VARCHAR(128) NOT NULL,
  sent                   TIMESTAMP    NOT NULL,
  username               VARCHAR(60)  NOT NULL,
  user_avatar_image_link VARCHAR(256) NOT NULL
);
-----

⌨️ 在 `src/main/resources` 目录创建一个名为 `sql` 的文件夹。 然后将上面的 SQL 代码放到 `src/main/resources/sql/schema.sql` 文件中。

image::{images}/schema-sql-location.png[]

还有， 你应该修改 `application.properties` 使之包含以下属性：

[source,properties]
-----
spring.datasource.schema=classpath:sql/schema.sql
spring.datasource.url=jdbc:h2:file:./build/data/testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.datasource.initialization-mode=always
-----

=== 操纵数据

使用 Spring Data, 上面提到的那个表可以使用以下的领域类来表达，它应该放到 `src/main/kotlin/com/example/kotlin/chat/repository/DomainModel.kt ` 文件中：

[source,kotlin]
-----
import org.springframework.data.annotation.Id
import org.springframework.data.relational.core.mapping.Table
import java.time.Instant

@Table("MESSAGES")
data class Message(
    val content: String,
    val contentType: ContentType,
    val sent: Instant,
    val username: String,
    val userAvatarImageLink: String,
    @Id var id: String? = null)

enum class ContentType {
    PLAIN
}
-----

这里有些需要解释的。 像 `content`, `sent` 和 `id` 等字段是对照 `MessageVM` 类的。 然而，为了减少表的数量和简化最终的关系结构，我们已经扁平化了 `User` 对象，并使它的字段是 `Message`
类的一部分。 除此之外，这里还有一个新的字段称为 `contentType`, 这表示所保存的消息的内容类型。 因为大多现代的聊天应用支持不同类型的标记语言，所以支持不同的消息内容编码是很常见的。 刚开始我们只是支持 `PLAIN` 纯文本，不过后面我们会扩展 `ContentType` 也以支持 `MARKDOWN` 类型。
Once we have the table representation as a class, we may introduce convenient access to the data via `Repository`.
一旦我们将表以一个类表达出来，我们可以通过 `Repository` 引入方便的访问。

⌨️  将 `MessageRepository.kt` 放到 `src/main/kotlin/com/example/kotlin/chat/repository` 文件夹。

[source,kotlin]
-----
import org.springframework.data.jdbc.repository.query.Query
import org.springframework.data.repository.CrudRepository
import org.springframework.data.repository.query.Param

interface MessageRepository : CrudRepository<Message, String> {

    // language=SQL
    @Query("""
        SELECT * FROM (
            SELECT * FROM MESSAGES
            ORDER BY "SENT" DESC
            LIMIT 10
        ) ORDER BY "SENT"
    """)
    fun findLatest(): List<Message>

    // language=SQL
    @Query("""
        SELECT * FROM (
            SELECT * FROM MESSAGES
            WHERE SENT > (SELECT SENT FROM MESSAGES WHERE ID = :id)
            ORDER BY "SENT" DESC
        ) ORDER BY "SENT"
    """)
    fun findLatest(@Param("id") id: String): List<Message>
}
-----

我们的 `MessageRepository` 继承了一个普通的 `CrudRepository` 并提供了两个不同的带有自定义查询的方法，分别用于查询最新消息和根据特定 ID获取消息。

💡 你有没有注意到 SQL 查询采用了可读性好的 多行字符串 格式？ Kotlin 为字符串提供了一系列有用的额外特性。 你可以在Kotlin文档学习更多关于这些额外特性。

下一步是实现会与 `MessageRepository` 集成的 `MessageService` 类

⌨️ 将那个 `PersistentMessageService` 类放到 `src/main/kotlin/com/example/kotlin/chat/service` 文件夹，替换掉 `FakeMessageService` 实现。


[source,kotlin]
-----
package com.example.kotlin.chat.service

import com.example.kotlin.chat.repository.ContentType
import com.example.kotlin.chat.repository.Message
import com.example.kotlin.chat.repository.MessageRepository
import org.springframework.context.annotation.Primary
import org.springframework.stereotype.Service
import java.net.URL

@Service
@Primary
class PersistentMessageService(val messageRepository: MessageRepository) : MessageService {

    override fun latest(): List<MessageVM> =
        messageRepository.findLatest()
            .map { with(it) { MessageVM(content, UserVM(username,
                              URL(userAvatarImageLink)), sent, id) } }

    override fun after(lastMessageId: String): List<MessageVM> =
        messageRepository.findLatest(lastMessageId)
            .map { with(it) { MessageVM(content, UserVM(username,
                              URL(userAvatarImageLink)), sent, id) } }

    override fun post(message: MessageVM) {
        messageRepository.save(
            with(message) { Message(content, ContentType.PLAIN, sent,
                         user.name, user.avatarImageLink.toString()) }
        )
    }
}
-----

`PersistentMessageService` 是 `MessageRepository` 的简单封装，由于我们这里只是做一些简单的对象封装。所有的业务查询都发生在 `Repository` 层面。另一方面，这种实现的简洁性是 Kotlin 语言的优点，它提供了像 `map` 和 `with` 等的扩展函数。

如果我们现在启动应用，我们再次看到空的聊天页面。 然而，如果我们输入一条消息到文本输入框并发送它，一会我们将会看到它出现在屏幕中。 如果我们打开一个新的浏览器页面，我们还会在消息历史中看到这条消息。

最后，我们可以写一些集成测试以确保我们的代码随时间流逝还能正常地运行。

=== 添加集成测试

要开始，我们需要修改 `/src/test`目录中的 `ChatKotlinApplicationTests`文件，并且添加我们在测试中需要用到的字段。


[source,kotlin]
-----
import com.example.kotlin.chat.repository.ContentType
import com.example.kotlin.chat.repository.Message
import com.example.kotlin.chat.repository.MessageRepository
import com.example.kotlin.chat.service.MessageVM
import com.example.kotlin.chat.service.UserVM
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.ValueSource
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.web.client.TestRestTemplate
import org.springframework.boot.test.web.client.postForEntity
import org.springframework.core.ParameterizedTypeReference
import org.springframework.http.HttpMethod
import org.springframework.http.RequestEntity
import java.net.URI
import java.net.URL
import java.time.Instant
import java.time.temporal.ChronoUnit.MILLIS

@SpringBootTest(
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        properties = [
            "spring.datasource.url=jdbc:h2:mem:testdb"
        ]
)
class ChatKotlinApplicationTests {

    @Autowired
    lateinit var client: TestRestTemplate

    @Autowired
    lateinit var messageRepository: MessageRepository

    lateinit var lastMessageId: String

    val now: Instant = Instant.now()
}
-----

我们使用 lateinit 关键字， 它非常适用于延迟非空字段初始化的场景。 在我们的例子中，我用它去 `@Autowire` 那个 `MessageRepository` 字段，并且解析 `TestRestTemplate`。

为简单起见，我们会测试以下三个一般用例：

* 当 `lastMessageId` 不可用时解析消息的情况
* 当 `lastMessageId` 存在时 解析消息的情况
* 以及发送消息。

为了测试消息的解析情况， 我们需要准备一些测试消息，并且需要在每个测试用例完成后清空存储的内容。 添加以下内容到 `ChatKotlinApplicationTests`: 


[source,kotlin]
-----
@BeforeEach
fun setUp() {
    val secondBeforeNow = now.minusSeconds(1)
    val twoSecondBeforeNow = now.minusSeconds(2)
    val savedMessages = messageRepository.saveAll(listOf(
            Message(
                    "*testMessage*",
                    ContentType.PLAIN,
                    twoSecondBeforeNow,
                    "test",
                    "http://test.com"
            ),
            Message(
                    "**testMessage2**",
                    ContentType.PLAIN,
                    secondBeforeNow,
                    "test1",
                    "http://test.com"
            ),
            Message(
                    "`testMessage3`",
                    ContentType.PLAIN,
                    now,
                    "test2",
                    "http://test.com"
            )
    ))
    lastMessageId = savedMessages.first().id ?: ""
}

@AfterEach
fun tearDown() {
    messageRepository.deleteAll()
}
-----


一旦准备工作完成了，我们可以为获取消息创建第一个测试用例。

[source,kotlin]
-----
@ParameterizedTest
@ValueSource(booleans = [true, false])
fun `test that messages API returns latest messages`(withLastMessageId: Boolean) {
    val messages: List<MessageVM>? = client.exchange(
        RequestEntity<Any>(
            HttpMethod.GET,
            URI("/api/v1/messages?lastMessageId=${if (withLastMessageId) lastMessageId else ""}")
            ),
            object : ParameterizedTypeReference<List<MessageVM>>() {}).body

    if (!withLastMessageId) {
        assertThat(messages?.map { with(it) { copy(id = null, sent = sent.truncatedTo(MILLIS))}})
                .first()
                .isEqualTo(MessageVM(
                        "*testMessage*",
                        UserVM("test", URL("http://test.com")),
                        now.minusSeconds(2).truncatedTo(MILLIS)
                ))
    }

    assertThat(messages?.map { with(it) { copy(id = null, sent = sent.truncatedTo(MILLIS))}})
            .containsSubsequence(
                    MessageVM(
                            "**testMessage2**",
                            UserVM("test1", URL("http://test.com")),
                            now.minusSeconds(1).truncatedTo(MILLIS)
                    ),
                    MessageVM(
                            "`testMessage3`",
                            UserVM("test2", URL("http://test.com")),
                            now.truncatedTo(MILLIS)
                    )
            )
}
-----

💡 所有的数据类都有一个 `copy` 方法，可让你完全拷贝一个实例的同时还可以按需自定义某些字段。 在我们例子中，这是非常有用的，因为我们想截短已发送消息的时间戳使之成为同样的时间单位，以便我们比较时间戳。


💡 Kotlin 对字符串模板的支持是对测试的很好的附加。

一旦我们实现了这个测试，最后需要实现的就是消息发送测试。将以下代码添加到 `ChatKotlinApplicationTests` 文件：

[source,kotlin]
-----
@Test
fun `test that messages posted to the API is stored`() {
    client.postForEntity<Any>(
            URI("/api/v1/messages"),
            MessageVM(
                    "`HelloWorld`",
                    UserVM("test", URL("http://test.com")),
                    now.plusSeconds(1)
            )
    )

    messageRepository.findAll()
            .first { it.content.contains("HelloWorld") }
            .apply {
                assertThat(this.copy(id = null, sent = sent.truncatedTo(MILLIS)))
                        .isEqualTo(Message(
                                "`HelloWorld`",
                                ContentType.PLAIN,
                                now.plusSeconds(1).truncatedTo(MILLIS),
                                "test",
                                "http://test.com"
                        ))
            }
}
-----

💡 在测试方法中可以使用反引号括起包含空格的函数命。 见相关文档 https://kotlinlang.org/docs/reference/coding-conventions.html#function-names[documentation].


上面的测试看起来跟之前的相似，除了我们要确认已发送的消息是存在数据库中。在这个例子中，我们可以看到 `run` 作用域的函数，这可以使得在调用作用域内的目标对象作为 `this` 。


一旦我们实现了所有这些测试， 我们可以运行它们看是否可以通过。


image::{images}/intellij-running-tests.png[]

在这个阶段，我们为聊天应用添加了消息持久化功能。 这些消息现在可以传送到所有连接到应用程序的活动客户端。
另外，我们现在也可以访问历史数据，所以所有人都可以访问到之前的消息，如果他们想的话。


这个实现看起来可能完成了，但我们写的代码还有些提升的空间。 因为，在下一个步骤，我们会看看使用Kotlin扩展可以如何改善我们的代码。

== 第3部分: 实现扩展

在这部分，我们会实现 扩展函数 以在一些地方减少重复代码的数量。

例如，你可能注意到 `Message` &lt;--> `MessageVM` 的转换当前是显式地发生在 `PersistableMessageService` 。我们同样想要通过添加 Markdown 支持去支持不同的内容类型。

首先，我们为 `Message` 和 `MessageVM` 创建扩展方法。 新的方法实现了 `Message` 和 `MessageVM` 来回转换的逻辑： 


[source,kotlin]
-----
import com.example.kotlin.chat.repository.ContentType
import com.example.kotlin.chat.repository.Message
import com.example.kotlin.chat.service.MessageVM
import com.example.kotlin.chat.service.UserVM
import java.net.URL

fun MessageVM.asDomainObject(contentType: ContentType = ContentType.PLAIN): Message = Message(
        content,
        contentType,
        sent,
        user.name,
        user.avatarImageLink.toString(),
        id
)

fun Message.asViewModel(): MessageVM = MessageVM(
        content,
        UserVM(username, URL(userAvatarImageLink)),
        sent,
        id
)
-----


⌨️   我们会将上面的函数存放在 `src/main/kotlin/com/example/kotlin/chat/Extensions.kt` 文件中。

现在既然我们已经扩展了 `MessageMV` 和 `Message` ， 我们可以在 `PersistentMessageService` 中使用它们了。



[source,kotlin]
-----
@Service
class PersistentMessageService(val messageRepository: MessageRepository) : MessageService {

    override fun latest(): List<MessageVM> =
            messageRepository.findLatest()
                    .map { it.asViewModel() }

    override fun after(lastMessageId: String): List<MessageVM> =
            messageRepository.findLatest(lastMessageId)
                    .map { it.asViewModel() }

    override fun post(message: MessageVM) {
        messageRepository.save(message.asDomainObject())
    }
}
-----

上边的代码比之前的好。 它更简介和易读了。 然而，我们还可以更进一步地改善它。 正如我们所看到的，带同样mapper的map()操作符我们使用了两次。 实际上，我们可以通过为 `List` 添加一个带指定泛型的自定义 `map` 函数去改善这种情况。 添加下面这行到 `Extensions.kt` 文件：


[source,kotlin]
-----
fun List<Message>.mapToViewModel(): List<MessageVM> = map { it.asViewModel() }
-----

加上了这一行之后， Kotlin 会提供相关的扩展方法到与指定泛型类型对应的任意`List`：

[source,kotlin]
-----
@Service
class PersistentMessageService(val messageRepository: MessageRepository) : MessageService {

    override fun latest(): List<MessageVM> =
        messageRepository.findLatest()
            .mapToViewModel() // now we can use the mentioned extension on List<Message>

    override fun after(lastMessageId: String): List<MessageVM> =
        messageRepository.findLatest(lastMessageId)
            .mapToViewModel()
    //...
}
-----

⚠️ 注意你不能在同一个类、同样的扩展名称不能使用不同的泛型。原因是类型擦除，这意味着在运行时，不同的类都是使用同样的方法，并且它是没办法猜测应该调用哪一个的。

一旦所有的扩展应用上了，我们可以使用类似的技巧在测试的类里面声明支持的扩展。将以下代码放到 `src/test/kotlin/com/example/kotlin/chat/TestExtensions.kt` 文件中。

[source,kotlin]
-----
import com.example.kotlin.chat.repository.Message
import com.example.kotlin.chat.service.MessageVM
import java.time.temporal.ChronoUnit.MILLIS

fun MessageVM.prepareForTesting() = copy(id = null, sent = sent.truncatedTo(MILLIS))

fun Message.prepareForTesting() = copy(id = null, sent = sent.truncatedTo(MILLIS))
-----

现在我们可以继续实现对 `MARKDOWN` 内容类型的支持。首先，我们需要添加Markdown内容渲染的工具包。 为此，我们可以添加来自 JetBrains 官方的 Markdown 库依赖到我们的 `build.gradle.kts` 文件。

[source]
-----
dependencies {
   ...
   implementation("org.jetbrains:markdown:0.1.45")
   ...
}
-----

既然我们已经学到了如何使用扩展， 让我们在 `Extensions.kt` 文件中创建另一个 `ContentType` enum 的扩展，这样每个 enum 值会知道如何渲染特定的内容。

[source,kotlin]
-----
fun ContentType.render(content: String): String = when (this) {
    ContentType.PLAIN -> content
}
-----

在上面的例子中， 我们使用了 `when` 表达式， 它提供了 Kotlin 中的模式匹配。 如果 `when` 是用作表达式， 那么 `else` 分支是必须的。 然而， 如果 `when` 是用于可穷举的值（例如，有常数个输出结果的 `enum`  或 有定义一定数量的子类的 `sealed classes`），那么这时候 `else` 分支就不是必要的。 上面的例子正是这样的一种情况，我们知道在编译期就知道了所有的可能输出（而且所有的都处理好了），因此我们不需要指定 `else` 分支。

现在我们知道了 `when` 表达式的原理，让我们最后再添加第二个选项到 `ContentType` enum:

[source,kotlin]
-----
enum class ContentType {
    PLAIN, MARKDOWN
}
-----

`when` 表达式强大之处体现在有强烈的穷举性需求的时候。任何时候当一个新的值添加到了 `enum`，我们可以在推送软件到生产环境之前修复编译问题：

[source,kotlin]
-----
fun ContentType.render(content: String): String = when (this) {
    ContentType.PLAIN -> content
    ContentType.MARKDOWN -> {
        val flavour = CommonMarkFlavourDescriptor()
        HtmlGenerator(content, MarkdownParser(flavour).buildMarkdownTreeFromString(content),
           flavour).generateHtml()
    }
}
-----

当我们修复了 `render` 方法以支持新的 `ContentType` ， 我们可以修改 `Message` 和 `MessageVM` 的扩展方法去启用 `MARKDOWN` 类型渲染相应的内容:

[source,kotlin]
-----
fun MessageVM.asDomainObject(contentType: ContentType = ContentType.MARKDOWN): Message = Message(
        content,
        contentType,
        sent,
        user.name,
        user.avatarImageLink.toString(),
        id
)

fun Message.asViewModel(): MessageVM = MessageVM(
        contentType.render(content),
        UserVM(username, URL(userAvatarImageLink)),
        sent,
        id
)
-----

我们也需要修改测试用例确保 `MARKDOWN` 内容类型被正确地渲染。为此，我们需要更改 `ChatKotlinApplicationTests.kt` 并修改以下内容：

[source,kotlin]
-----
@BeforeEach
fun setUp() {
    //...
            Message(
                    "*testMessage*",
                    ContentType.PLAIN,
                    twoSecondBeforeNow,
                    "test",
                    "http://test.com"
            ),
            Message(
                    "**testMessage2**",
                    ContentType.MARKDOWN,
                    secondBeforeNow,
                    "test1",
                    "http://test.com"
            ),
            Message(
                    "`testMessage3`",
                    ContentType.MARKDOWN,
                    now,
                    "test2",
                    "http://test.com"
            )
   //...
}

@ParameterizedTest
@ValueSource(booleans = [true, false])
fun `test that messages API returns latest messages`(withLastMessageId: Boolean) {
    //...

    assertThat(messages?.map { it.prepareForTesting() })
            .containsSubsequence(
                    MessageVM(
                            "<body><p><strong>testMessage2</strong></p></body>",
                            UserVM("test1", URL("http://test.com")),
                            now.minusSeconds(1).truncatedTo(MILLIS)
                    ),
                    MessageVM(
                            "<body><p><code>testMessage3</code></p></body>",
                            UserVM("test2", URL("http://test.com")),
                            now.truncatedTo(MILLIS)
                    )
            )
}

@Test
fun `test that messages posted to the API are stored`() {
    //...
    messageRepository.findAll()
            .first { it.content.contains("HelloWorld") }
            .apply {
                assertThat(this.prepareForTesting())
                        .isEqualTo(Message(
                                "`HelloWorld`",
                                ContentType.MARKDOWN,
                                now.plusSeconds(1).truncatedTo(MILLIS),
                                "test",
                                "http://test.com"
                        ))
            }
}
-----

修改为完成后， 我们会看到全部的测试仍能通过， 而且 `MARKDOWN` 内容类型能被按照预期地渲染。

在这一步， 我们学习了如何使用扩展去改善代码质量。 我们也学习了 `when` 表达式以及它是如何在添加新的业务特性时减少人为错误的。

== 第4部分：重构代码为在 Spring WebFlux 中使用 Kotlin 协程

在教程的这部分， 我们会修改代码添加 Kotlin 协程的支持。

本质上， 协程是轻量级的线程使得异步代码可以用命令式表达。这就解决了很多与回调（观察者）模式相关的问题，上面就使用了这样的方式去达到同样的效果。

⚠️ 在本教程，我们不会深入讲协程以及 *kotilnx.coroutines* 标准库。 想学习协程及其特性，请看以下教程 https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/01_Introduction[tutorial].


=== 添加协程

要开始使用 Kotlin 协程， 我们需要添加三个额外的库到 `build.gradle.kts`文件：

[source]
-----
dependencies {
    ...
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactive")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
    ...
}
-----

一旦我们添加完了依赖，我们就可以开始使用协程相关的主要关键字： `suspend`. 这个 `suspend` 关键字表示被调用的函数是异步的。 不像其它的语言，类似的概念是通过 `async` 或 `await` 关键字表达，
那个 `suspend` 函数必须在协程上下文处理，它要么是另一个 `suspend` 函数或者是一个通过 `CoroutineScope.launch` 显式创建的协程 `Job` 或者是 `runBlocking` 函数。

因此， 作为将协程引入我们工程的第一步，我们会添加 `suspend` 关键字到工程里所有的 controllers 和 service 方法。 例如，修改之后的代码， 那个 `MessageService` 接口看起来像是这样的：

[source,kotlin]
-----
interface MessageService {

    suspend fun latest(): List<MessageVM>

    suspend fun after(lastMessageId: String): List<MessageVM>

    suspend fun post(message: MessageVM)
}
-----


上面的修改也会影响到代码中用到 `MessageService` 的地方。所有在 `PersistentMessageService` 中的函数都要相应地更新为带 `suspend` 关键字。



[source,kotlin]
-----
@Service
class PersistentMessageService(val messageRepository: MessageRepository) : MessageService {

   override suspend fun latest(): List<MessageVM> =
       messageRepository.findLatest()
           .mapToViewModel()

   override suspend fun after(messageId: String): List<MessageVM> =
       messageRepository.findLatest(messageId)
           .mapToViewModel()

   override suspend fun post(message: MessageVM) {
       messageRepository.save(message.asDomainObject())
   }
}
-----

处理请求的 `HtmlController` 和 `MessageResource` 也都需要调整：

[source,kotlin]
-----
// src/main/kotlin/com/example/kotlin/chat/controller/HtmlController.kt

@Controller
class HtmlController(val messageService: MessageService) {

   @GetMapping("/")
   suspend fun index(model: Model): String {
       //...
   }
}
-----

[source,kotlin]
-----
// src/main/kotlin/com/example/kotlin/chat/controller/MessageResource.kt

@RestController
@RequestMapping("/api/v1/messages")
class MessageResource(val messageService: MessageService) {

   @GetMapping
   suspend fun latest(@RequestParam(value = "lastMessageId", defaultValue = "") lastMessageId: String): ResponseEntity<List<MessageVM>> {
       //...
   }

   @PostMapping
   suspend fun post(@RequestBody message: MessageVM) {
       //...
   }
}
-----


现在我们已准备好将代码迁移到响应式 Spring 技术栈了，WebFlux. 继续看下去吧！


=== 添加 WebFlux 和 R2DBC

尽管大多数情况下添加 `org.jetbrains.kotlinx:kotlinx-coroutines-core` 依赖就够了，为了恰当地与 Spring 框架集成，我们需要替换掉 web 和 数据库模块：


[source]
-----
dependencies {
    ...
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jdbc")
    ...
}
-----

为以下内容：

[source]
-----
dependencies {
    ...
    implementation("org.springframework.boot:spring-boot-starter-webflux")
    implementation("org.springframework.boot:spring-boot-starter-data-r2dbc")
    implementation("io.r2dbc:r2dbc-h2")
    ...
}
-----

通过添加上面的依赖，我们用完全响应式(反应式)且非阻塞的 WebFlux 替换掉了标准的阻塞式的 Web MVC。 还有就是，JDBC 也替换为完全响应式且非阻塞的 R2DBC。


幸好有所有 Spring 框架工程师们的辛勤劳动，从 Spring Web MVC 迁移到 WebFlux 是顺滑的，我们什么都不用重写！ 然而对于 R2DBC, 我们需要一些额外步骤。 首先，我们需要添加一个配置类。


⌨️   我们将这个类放到 `com/example/kotlin/chat/ChatKotlinApplication.kt` 文件中，也就是我们应用程序 `main()` 方法所在的地方。

[source,kotlin]
-----
@Configuration
class Config {

    @Bean
    fun initializer(connectionFactory: ConnectionFactory): ConnectionFactoryInitializer {
        val initializer = ConnectionFactoryInitializer()
        initializer.setConnectionFactory(connectionFactory)
        val populator = CompositeDatabasePopulator()
        populator.addPopulators(ResourceDatabasePopulator(ClassPathResource("./sql/schema.sql")))
        initializer.setDatabasePopulator(populator)
        return initializer
    }
}
-----

上面的配置确保了数据表的模式在应用程序启动时会被初始化。


接下来，我们需要修改 `application.properties` 的属性以包含一个属性：


[source,properties]
-----
spring.r2dbc.url=r2dbc:h2:file:///./build/data/testdb;USER=sa;PASSWORD=password
-----

当我们作了一些基础配置相关的更改，我们会进行从 Spring Data JDBC 到 Spring Data R2DBC 的迁移。 为此我们需要更新 `MessageRepository` 接口到从 `CoroutineCrudRepository` 继承，并使用
`suspend` 关键字标记它的方法。 就像这边代码所示：


[source,kotlin]
-----
interface MessageRepository : CoroutineCrudRepository<Message, String> {

    // language=SQL
    @Query("""
        SELECT * FROM (
            SELECT * FROM MESSAGES
            ORDER BY "SENT" DESC
            LIMIT 10
        ) ORDER BY "SENT"
    """)
    suspend fun findLatest(): List<Message>

    // language=SQL
    @Query("""
        SELECT * FROM (
            SELECT * FROM MESSAGES
            WHERE SENT > (SELECT SENT FROM MESSAGES WHERE ID = :id)
            ORDER BY "SENT" DESC
        ) ORDER BY "SENT"
    """)
    suspend fun findLatest(@Param("id") id: String): List<Message>
}
-----

`CoroutineCrudRepository` 里的方法的设计都有考虑到 Kotlin 协程的。

⚠️ 注意到那个 `@Query` 注解现在是在不同的包了，所以需要按下面这样子导入它：

[source,kotlin]
-----
import org.springframework.data.r2dbc.repository.Query
-----

在这个阶段，这些更改应该足以让你的应用变成异步和非阻塞的了。 当重新运行应用，从功能的角度看，没有什么变化，但现在它使异步非阻塞地执行了。

最后，我们也需要修改以下我们的测试用例。 因为现在我们的 `MessageRepository` 是异步的了，我们需要修改数据源的 URL 并且在协程的上下文中执行相关的操作，如下面所示，用 `runBlocking` 将代码包起来（在 `ChatKotlinApplicationTests.kt` 文件中：

[source,kotlin]
-----
// ...
// new imports
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking

@SpringBootTest(
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        properties = [
            "spring.r2dbc.url=r2dbc:h2:mem:///testdb;USER=sa;PASSWORD=password"
        ]
)
class ChatKotlinApplicationTests {
    //...

    @BeforeEach
    fun setUp() {
       runBlocking {
        //...
       }
    }

    @AfterEach
    fun tearDown() {
       runBlocking {
        //...
       }
    }

    //...

    @Test
    fun `test that messages posted to the API is stored`() {
       runBlocking {
        //...
       }
    }
}
-----

我们的应用现在已经是异步和非阻塞的了。 不过它还是使用轮询的方式将消息从后端送到前端的UI。在下一部分，我们会将应用改为使用 RSocket 流式传输消息到所有已连接的客户端。


== 第5部分：使用 RSocket 进行流式传输

我们会使用 RSocket 将消息传输转为类似流式传输的方式。

RSocket 是一种二进制协议用在像 TCP 和 WebSocket 这样的字节流传输层。它提供了多种编程语言的 API，包括 Kotlin。 然而， 在我们的例子中，我们不需要直接使用那个API。我们使用 Spring Messaging， 它整合了 RSocket 并提供了一种基于注解的配置方式。

要开始在 Spring 中使用 RSocket ，我们需要添加和导入新的依赖到 `build.gradle.kts`:

[source]
-----
dependencies {
    ....
     implementation("org.springframework.boot:spring-boot-starter-rsocket")
    ....
}
-----


接下来，我们要更新 `MessageRepository` 让它通过 `Flow&lt;Messages>` 而不是 `List` 去返回一个异步的消息流。

[source,kotlin]
-----
interface MessageRepository : CoroutineCrudRepository<Message, String> {

    //...
    fun findLatest(): Flow<Message>

    //...
    fun findLatest(@Param("id") id: String): Flow<Message>
}
-----

我们需要对 `MessageService` 接口作类似的修改使它为流式传输做好准备。我们不需要那个 `suspend` 关键字了。 我们将使用 `Flow` 接口来表示异步的数据流。 任何之前输出 `List` 结果的函数现在将会输出 `Flow`。 发送消息的方法也将会接受 `Flow` 类型作为参数。

[source]
-----
import kotlinx.coroutines.flow.Flow

interface MessageService {

   fun latest(): Flow<MessageVM>

   fun after(messageId: String): Flow<MessageVM>

   fun stream(): Flow<MessageVM>

   suspend fun post(messages: Flow<MessageVM>)
}
-----

现在思路清晰了，可以更新 `PersistentMessageService` 整合上面的修改了。

[source,kotlin]
-----
import com.example.kotlin.chat.asDomainObject
import com.example.kotlin.chat.asRendered
import com.example.kotlin.chat.mapToViewModel
import com.example.kotlin.chat.repository.MessageRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.collect
import org.springframework.stereotype.Service

@Service
class PersistentMessageService(val messageRepository: MessageRepository) : MessageService {

   val sender: MutableSharedFlow<MessageVM> = MutableSharedFlow()

   override fun latest(): Flow<MessageVM> =
       messageRepository.findLatest()
           .mapToViewModel()

   override fun after(messageId: String): Flow<MessageVM> =
       messageRepository.findLatest(messageId)
           .mapToViewModel()

   override fun stream(): Flow<MessageVM> = sender

   override suspend fun post(messages: Flow<MessageVM>) =
       messages
           .onEach { sender.emit(it.asRendered()) }
           .map {  it.asDomainObject() }
           .let { messageRepository.saveAll(it) }
           .collect()
}
-----

首先，因为 `MessageService` 接口已经修改了，我们需要在对应的实现更新方法签名。 所以，之前我们在 `Extension.kt` 文件中为 `List` 类型定义的 `mapToViewModel` 扩展方法现在需要改为针对 `Flow` 类型的了。


[source,kotlin]
-----
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

fun Flow<Message>.mapToViewModel(): Flow<MessageVM> = map { it.asViewModel() }
-----

为可读性起见，我们也需要给 `MessageVM` 类添加 `asRendered` 扩展函数。 在 `Extensions.kt` 文件中：

[source,kotlin]
-----
fun MessageVM.asRendered(contentType: ContentType = ContentType.MARKDOWN): MessageVM =
   this.copy(content = contentType.render(this.content))
-----

接下来，我们将使用协程 API里面的 `MutableSharedFlow` 去广播消息到已连接的客户端。

做了修改我们已经接近想要的UI效果了。 然后，我们将更新 `MessageResource` 和 `HtmlController`。

`MessageResource` 完全是新的实现。 首先，我们通过使用 `@MessageMapping` 而不是 `@RequestMapping` 注解去让这个类支持消息通信。 新的方法 `send()` 和 `receive()` 都是通过 `@MessageMapping` 映射到同一个端点，用于双向通信。


[source,kotlin]
-----
@Controller
@MessageMapping("api.v1.messages")
class MessageResource(val messageService: MessageService) {

   @MessageMapping("stream")
   suspend fun receive(@Payload inboundMessages: Flow<MessageVM>) =
       messageService.post(inboundMessages)

   @MessageMapping("stream")
   fun send(): Flow<MessageVM> = messageService
       .stream()
       .onStart {
           emitAll(messageService.latest())
       }
}
-----

为了发送消息到 UI，我们打开一个来自 `messageService` 的 `stream`，这是由 `PersistentMessageService` 类实现的，然后调用 `onStart` 方法开始流式传输事件。当一个新的客户端连接到服务，它会首先受到历史消息，这是因为 `onStart` 方法中作为参数的一段代码: `emitAll(messageService.latest())` 。 然后这个通道就保持开启随时可以传输新消息。

那个 `HtmlController` 类不再需要处理任何流式传输的逻辑。它现在的作用是服务静态页面，所以它的实现就很简单（无关紧要的）：


[source,kotlin]
-----
@Controller
class HtmlController() {

   @GetMapping("/")
   fun index(): String {
       // implemented in src/main/resources/templates/chatrs.html
       return "chatrs"
   }
}
-----

注意到现在 UI 模板是 `chatrs.html` 而不是 `chat.html` 了。 新的模板引擎包含了 JavaScript 代码，用于配置 _WebSocket_ 连接和直接与 `MessageResource` 类实现的 `api.v1.messages.stream` 端点交互。

最后我们还需要修改 `application.properties` 文件使之适用于 RSocket。 添加以下属性到配置中：

[source,properties]
-----
spring.rsocket.server.transport=websocket
spring.rsocket.server.mapping-path=/rsocket
-----

这个应用已预备好启动了！得益于RSocket现在消息无需轮询就可以传到聊天UI了。还有就是后端应用完全异步和非阻塞的了，这得益于Spring WebFlux和Kotlin 协程。

我们教程的最后一步是更新这些测试。

我们需要特定为测试添加更多的依赖。 Turbine 是一个小的测试库。 它通过提供一些有用的扩展去简化了 kotlinx.coroutines 的 `Flow` 接口

[source]
-----
dependencies {
    ...
    testImplementation("app.cash.turbine:turbine:0.3.0")
    ...
}
-----

这个库的入口是 `Flow&lt;T&gt;` 的 `test()` 扩展，它以一段实现了校验逻辑的代码作为参数。 那个 `test()` 扩展时一个悬挂(suspending)函数，直到flow完成了或取消了才会返回。我们稍后会看看它的用处。

接下来，更新测试依赖。 我们不通过字段自动装配，而是使用构造器注入依赖。

[source,kotlin]
-----
class ChatKotlinApplicationTests {

   @Autowired
   lateinit var client: TestRestTemplate

   @Autowired
   lateinit var messageRepository: MessageRepository

class ChatKotlinApplicationTests(
   @Autowired val rsocketBuilder: RSocketRequester.Builder,
   @Autowired val messageRepository: MessageRepository,
   @LocalServerPort val serverPort: Int
) {
-----

我们使用 `RSocketRequest.Builder` 而不是 `TestRestTemplate`因为由 `MessageResource` 实现的端点是通过 RSocket 协议通信的。在测试中，我们需要构造一个 `RSocketRequester` 实例，并使用它去发起请求。 用下面的代码替换掉旧的测试：

[source,kotlin]
-----
@ExperimentalTime
@ExperimentalCoroutinesApi
@Test
fun `test that messages API streams latest messages`() {
   runBlocking {
       val rSocketRequester =
            rsocketBuilder.websocket(URI("ws://localhost:${serverPort}/rsocket"))

       rSocketRequester
           .route("api.v1.messages.stream")
           .retrieveFlow<MessageVM>()
           .test {
               assertThat(expectItem().prepareForTesting())
                   .isEqualTo(
                       MessageVM(
                           "*testMessage*",
                           UserVM("test", URL("http://test.com")),
                           now.minusSeconds(2).truncatedTo(MILLIS)
                       )
                   )

               assertThat(expectItem().prepareForTesting())
                   .isEqualTo(
                       MessageVM(
                           "<body><p><strong>testMessage2</strong></p></body>",
                           UserVM("test1", URL("http://test.com")),
                           now.minusSeconds(1).truncatedTo(MILLIS)
                       )
                   )
               assertThat(expectItem().prepareForTesting())
                   .isEqualTo(
                       MessageVM(
                           "<body><p><code>testMessage3</code></p></body>",
                           UserVM("test2", URL("http://test.com")),
                           now.truncatedTo(MILLIS)
                       )
                   )

               expectNoEvents()

               launch {
                   rSocketRequester.route("api.v1.messages.stream")
                       .dataWithType(flow {
                           emit(
                               MessageVM(
                                   "`HelloWorld`",
                                   UserVM("test", URL("http://test.com")),
                                   now.plusSeconds(1)
                               )
                           )
                       })
                       .retrieveFlow<Void>()
                       .collect()
               }

               assertThat(expectItem().prepareForTesting())
                   .isEqualTo(
                       MessageVM(
                           "<body><p><code>HelloWorld</code></p></body>",
                           UserVM("test", URL("http://test.com")),
                           now.plusSeconds(1).truncatedTo(MILLIS)
                       )
                   )

               cancelAndIgnoreRemainingEvents()
           }
   }
}

@ExperimentalTime
@Test
fun `test that messages streamed to the API is stored`() {
   runBlocking {
       launch {
           val rSocketRequester =
                rsocketBuilder.websocket(URI("ws://localhost:${serverPort}/rsocket"))

           rSocketRequester.route("api.v1.messages.stream")
               .dataWithType(flow {
                   emit(
                       MessageVM(
                           "`HelloWorld`",
                           UserVM("test", URL("http://test.com")),
                           now.plusSeconds(1)
                       )
                   )
               })
               .retrieveFlow<Void>()
               .collect()
       }

       delay(2.seconds)

       messageRepository.findAll()
           .first { it.content.contains("HelloWorld") }
           .apply {
               assertThat(this.prepareForTesting())
                   .isEqualTo(
                       Message(
                           "`HelloWorld`",
                           ContentType.MARKDOWN,
                           now.plusSeconds(1).truncatedTo(MILLIS),
                           "test",
                           "http://test.com"
                       )
                   )
           }
   }
}
-----

== Summary 总结

这是我们教程的最后一个部分。 我们从一个简单的聊天应用开始，那个当界面查询新消息时后端是阻塞地查询数据库的。 我们逐步添加特性到这个应用并迁移到响应式Spring技术栈。后端现在已经完全异步，
利用了 Spring WebFlux 和 Kotlin 协程。
